using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class GameManager : MonoBehaviour {
    public int lives;
    public bool isPaused;
    int totalScore;
    Coroutine spawnTimer;

    public delegate void SimpleEventHandler();
    public GameObject TargetPrefab;
    public Text scoreText;
    public Image targetColorImage;

    public event SimpleEventHandler OnGamePause;
    public event SimpleEventHandler OnGameUnpause;
    public event SimpleEventHandler OnLevelWin;
    public event SimpleEventHandler OnLevelLose;
    public event SimpleEventHandler DestroyAllTargets;

    public static GameManager Instance;

    public LevelInfo levelInfo;

    private SpawnFactory Factory;

    // Start is called before the first frame update
    void Start() {
        if(Instance == null) {
            Instance = this;
        } else {
            Destroy(this);
        }
        setLevelInfo(new LevelInfo(1, 0, 1f, 0.8f, 5.0f, 2, 5, ColorCode.RED, 10));
        Factory = gameObject.AddComponent<SpawnFactory>();
        StartCoroutine(SpawnTimer());
    }



    /// <summary>
    /// This method controls when the player hits the pause button in the UI the Game pauses and the pause screen is activated.
    /// It also invokes the correct Pause Events.
    /// </summary>
    public void Pause() {
        isPaused = !isPaused;
        if(isPaused)
        {
            OnGamePause?.Invoke();
        }
        else
        {
            OnGameUnpause?.Invoke();
        }
    }
    
    /// <summary>
    /// This Coroutine is used to evalute the times that new Targets and new attacks should be generated by the Factory
    /// If the Game is Paused this should get caught in the is paused condition
    /// </summary>
    /// <returns></returns>
    IEnumerator SpawnTimer() {
        float timeSinceTargetSpawnBurst = GameManager.Instance.levelInfo.timeBetweenBursts - 1;
        float timeSinceAttackSpawn = 0;
        while (true) {
            if(isPaused) {
                yield return new WaitUntil(() => isPaused == false);
            }

            //Spawns bursts of targets utilizing SpawnFactory
            if(timeSinceTargetSpawnBurst > GameManager.Instance.levelInfo.timeBetweenBursts)
            {
                Factory.SpawnTargetBurst(Random.Range(levelInfo.targetSpawnMin,levelInfo.targetSpawnMax));
                timeSinceTargetSpawnBurst = 0;
            }

            yield return new WaitForEndOfFrame();
            timeSinceAttackSpawn += Time.deltaTime;
            timeSinceTargetSpawnBurst += Time.deltaTime;
        }
    }
   

    // Update is called once per frame
    void Update() {
        if(Input.GetKeyDown(KeyCode.P)) {
            Pause();
        }
        if(Input.GetKeyDown(KeyCode.D)) {
            //Debug to get to higher levels easier.
            BlowUpEverything();
        }
    }

    public void Score(float pointValue, ColorCode colorCode) {
        if(colorCode == levelInfo.targetColor) {
            totalScore += (int)(pointValue * levelInfo.scoreMultiplier);
            levelInfo.numTargetsToWin -= 1;
        } else {
            totalScore -= (int)(pointValue * levelInfo.scoreMultiplier);
        }
        if(levelInfo.numTargetsToWin <= 0) {
            //TODO: Stop this from being a mess
            ColorCode nextColor = (ColorCode)((int)(levelInfo.targetColor + 1)%4);
            int nextLevel = levelInfo.currentLevel + 1;
            float nextScoreMult = levelInfo.scoreMultiplier + 0.1f;
            float nextTimeBetweenBursts = levelInfo.timeBetweenBursts - 0.25f;
            nextTimeBetweenBursts = (nextTimeBetweenBursts <= 1.0f) ? 1.0f : nextTimeBetweenBursts;
            int nextTargetSpawnMin = (levelInfo.targetSpawnMin >= 11) ? 11 : levelInfo.targetSpawnMin + 1;
            int nextTargetSpawnMax = (levelInfo.targetSpawnMax >= 15) ? 15 : levelInfo.targetSpawnMax + 1;
            //TODO: Use a better formula for nextColorSpawnChance
            float nextLevelColorSpawnChance = Mathf.Lerp(levelInfo.goalTargetSpawnChance, 0.4f, 0.5f); //Lerps towards 0.4f spawn chance
            LevelInfo nextLevelInfo = new LevelInfo(nextLevel, 0, nextScoreMult, nextLevelColorSpawnChance, nextTimeBetweenBursts, nextTargetSpawnMin, nextTargetSpawnMax, nextColor, 10);
            setLevelInfo(nextLevelInfo);
        }
        scoreText.text = "Current Score: " + totalScore + "\nCurrent Level: " + levelInfo.currentLevel + "\nTargets to next Level: " + levelInfo.numTargetsToWin;
    }

    void setLevelInfo(LevelInfo levelInfo) {
        this.levelInfo = levelInfo;
        switch (levelInfo.targetColor) {
            case ColorCode.RED:
                targetColorImage.color = Color.red;
                break;
            case ColorCode.BLUE:
                targetColorImage.color = Color.blue;
                break;
            case ColorCode.GREEN:
                targetColorImage.color = Color.green;
                break;
            case ColorCode.MAGENTA:
                targetColorImage.color = Color.magenta;
                break;
            default:
                targetColorImage.color = Color.white;
                break;
        }
    }

    public void BlowUpEverything() {
        DestroyAllTargets?.Invoke();
    }
}

[System.Serializable]
public struct LevelInfo {
    public int currentLevel;
    public int currentScore;
    public float scoreMultiplier;
    public float timeBetweenBursts;
    public int targetSpawnMin;
    public int targetSpawnMax;
    public float goalTargetSpawnChance;
    public ColorCode targetColor;
    public float numTargetsToWin;

    //TODO: Evaluate whether or not the Lists of floats are really necessary.  Remove them if not
    //TODO: Evaluate whether or not currentScore is required.  If not remove it
    public LevelInfo(int curLevel, int curScore, float scoreMult, float tarSpawnChance, float timeBetweenBursts, int spawnSizeLowBound, int spawnSizeUpperBound, ColorCode targetColor, float numTargetsToWin)
    {
        this.currentLevel = curLevel;
        this.currentScore = curScore;
        this.scoreMultiplier = scoreMult;
        this.goalTargetSpawnChance = tarSpawnChance;
        this.timeBetweenBursts = timeBetweenBursts;
        this.targetSpawnMin = spawnSizeLowBound;
        this.targetSpawnMax = spawnSizeUpperBound;
        this.targetColor = targetColor;
        this.numTargetsToWin = numTargetsToWin;
    }
}
