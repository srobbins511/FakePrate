using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class GameManager : MonoBehaviour
{
    public int lives;
    public bool isPaused;
    int totalScore;
    Coroutine spawnTimer;

    public delegate void SimpleEventHandler();
    public GameObject TargetPrefab;
    public Text scoreText;
    public Image targetColorImage;

    public event SimpleEventHandler OnGamePause;
    public event SimpleEventHandler OnGameUnpause;
    public event SimpleEventHandler OnLevelWin;
    public event SimpleEventHandler OnLevelLose;
    public event SimpleEventHandler DestroyAllTargets;

    public static GameManager Instance;

    public LevelInfo levelInfo;

    private SpawnFactory Factory;

    //DEBUG: Getting fake levels working
    private int previousScore;

    // Start is called before the first frame update
    void Start()
    {
        if(Instance == null)
        {
            Instance = this;
        } 
        else
        {
            Destroy(this);
        }
        setLevelInfo(new LevelInfo(1, 0, 1f, 1f, 3, 7, new List<float>(), new List<float>(), ColorCode.RED));
        Factory = gameObject.AddComponent<SpawnFactory>();
        StartCoroutine(SpawnTimer());
        previousScore = 0;
    }



    /// <summary>
    /// This method controls when the player hits the pause button in the UI the Game pauses and the pause screen is activated.
    /// It also invokes the correct Pause Events.
    /// </summary>
    public void Pause()
    {
        isPaused = !isPaused;
        if(isPaused)
        {
            OnGamePause?.Invoke();
        }
        else
        {
            OnGameUnpause?.Invoke();
        }
    }
    
    /// <summary>
    /// This Coroutine is used to evalute the times that new Targets and new attacks should be generated by the Factory
    /// If the Game is Paused this should get caught in the is paused condition
    /// </summary>
    /// <returns></returns>
    IEnumerator SpawnTimer()
    {
        float timeSinceTargetSpawnBurst = 0;
        int targetSpawnBurstIndexPos = 0;
        int attackSpawnIndexPos = 0;
        float timeSinceAttackSpawn = 0;
        while (true)
        {
            if(isPaused)
            {
                yield return new WaitUntil(() => isPaused == false);
            }

            //this should contain the call to factory for spawning targets
            if(timeSinceTargetSpawnBurst > 2f /*levelInfo.TargetSpawnTimes[targetSpawnBurstIndexPos]*/)
            {
                /*
                targetSpawnBurstIndexPos++;
                if(levelInfo.TargetSpawnTimes.Count <= targetSpawnBurstIndexPos)
                {
                    targetSpawnBurstIndexPos = 0;
                }
                */
                //Update factory Call to Use autogenerated Variable numbers
                Factory.SpawnTargetBurst(Random.Range(5,15));
                timeSinceTargetSpawnBurst = 0;
            }
            /*
            //this should contain the call to factory for spawning attacks
            if(timeSinceAttackSpawn > levelInfo.AttackSpawnTimes[attackSpawnIndexPos])
            {
                attackSpawnIndexPos++;
                if(levelInfo.AttackSpawnTimes.Count <= attackSpawnIndexPos)
                {
                    attackSpawnIndexPos = 0;
                }

                //factory call here
                Factory.SpawnAtack();
            }
            */
            //TODO: FIX THIS CODE FROM BEING BROKEN; Time.deltaTime is based on Update not Coroutine
            timeSinceAttackSpawn += Time.deltaTime;
            timeSinceTargetSpawnBurst += Time.deltaTime;
            yield return new WaitForEndOfFrame();
        }
    }
   

    // Update is called once per frame
    void Update()
    {
        if(Input.GetKeyDown(KeyCode.P)) {
            Pause();
        }
    }

    public void Score(float pointValue, ColorCode colorCode)
    {
        if(colorCode == levelInfo.targetColor) {
            totalScore += (int)(pointValue * levelInfo.scoreMultiplier);
        } else {
            totalScore -= (int)(pointValue * levelInfo.scoreMultiplier);
        }
        scoreText.text = "Current Score: " + totalScore;
        Debug.Log("POINTS SCORED: " + totalScore);
        if(totalScore >= previousScore + 100) {
            //TODO: Stop this from being a broken mess
            ColorCode nextColor = (ColorCode)((int)(levelInfo.targetColor + 1)%4);
            LevelInfo nextLevelInfo = new LevelInfo(1, 0, 1f, 1f, 3, 7, new List<float>(), new List<float>(), nextColor);
            setLevelInfo(nextLevelInfo);
            previousScore = totalScore;
        }
    }

    void setLevelInfo(LevelInfo levelInfo) {
        this.levelInfo = levelInfo;
        switch (levelInfo.targetColor) {
            case ColorCode.RED:
                targetColorImage.color = Color.red;
                break;
            case ColorCode.BLUE:
                targetColorImage.color = Color.blue;
                break;
            case ColorCode.GREEN:
                targetColorImage.color = Color.green;
                break;
            case ColorCode.MAGENTA:
                targetColorImage.color = Color.magenta;
                break;
            default:
                targetColorImage.color = Color.white;
                break;
        }
    }

    public void BlowUpEverything() {
        DestroyAllTargets?.Invoke();
    }
}

[System.Serializable]
public struct LevelInfo
{
    
    public int currentLevel;
    public int currentScore;
    public float scoreMultiplier;
    public int targetSpawnBurstSize;
    public float goalTargetSpawnChance;
    public List<float> TargetSpawnTimes;
    public List<float> AttackSpawnTimes;
    public ColorCode targetColor;

    public LevelInfo(int curLevel, int curScore, float scoreMult, float tarSpawnChance, int spawnSizeLowBound, int spawnSizeUpperBound, List<float> tarSpawnTimes, List<float> attackSpawnTimes, ColorCode targetColor)
    {
        this.currentLevel = curLevel;
        this.currentScore = curScore;
        this.scoreMultiplier = scoreMult;
        this.goalTargetSpawnChance = tarSpawnChance;
        this.targetSpawnBurstSize = Random.Range(spawnSizeLowBound, spawnSizeUpperBound);
        this.TargetSpawnTimes = tarSpawnTimes;
        this.AttackSpawnTimes = attackSpawnTimes;
        this.targetColor = targetColor;
    }
}
